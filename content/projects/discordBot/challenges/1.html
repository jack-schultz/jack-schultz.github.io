<div>
    <h1>Storing Information</h1>

    <h2>Aim</h2>
    <p>
        When a user joins a specific, pre-determined voice channel (channel hub), I want to create
        a new voice channel (temporary voice channel) and move them into it. When the user leaves
        that channel, the temporary voice channel should be deleted.
    </p>

    <h2>Initial Plan</h2>
    <p>
        Originally, I was planning to only store the channel hubs' IDs and keep the temporary voice
        channels' IDs in a list in memory. However, this approach had a major flaw. If the bot
        restarted or crashed, it would stop tracking any existing temporary voice channels. This
        meant admins would have to manually delete any leftover temporary channels.
    </p>

    <h2>Improved Solution</h2>
    <p>
        To fix this issue, I redesigned the system to use persistent storage so the bot could recover its state after restarts or crashes.
        The only question was: which type of database? This led me to lightly research different
        types of databases. For my use case, I ended up choosing SQLite, as it's a simple and
        lightweight solution that works well. Since it's stored in a file, I could view and query
        the database easily through my IDE, which aided my learning.
    </p>

    <h2>Refactoring for Maintainability</h2>
    <p>
        As the project grew, manually managing the database queries became messy and hard to track.
        To improve modularity, I implemented a database abstraction layer to decouple persistence
        logic from business logic, improving maintainability and extensibility.
    </p>
    <p>
        As new functionality was implemented, the database schema had to be considered. New features often required new columns
        in the database which may not exist in older instances. To solve this, I implemented automatic schema
        migration to ensure forward compatibility without manual database intervention. This was
        done by storing new columns in a dictionary which checks for their existence and adds them with default data if missing
    </p>

    <h2>Results</h2>
    <p>
        The bot now consistently handles temporary voice channels without leaving any orphaned
        ones behind, even after restarts or crashes. SQLite proved to be reliable and low-maintenance,
        and the abstraction layer made the overall codebase more maintainable. Users
        were moved seamlessly between channels, and admins no longer had to worry about manual cleanups.
    </p>

    <h2>What I Learned</h2>
    <p>
        I learned that even small-scale features can benefit from persistent storage and a bit
        of foresight into failure cases. I also gained a much deeper understanding of working
        with SQLite in a real project and how to abstract logic in a way that improves
        maintainability. Most importantly, I saw the value of planning for edge cases, especially
        in bots that are expected to run 24/7.
    </p>
    <ul>
        <li>Persistent state management</li>
        <li>Schema migration strategies</li>
        <li>Abstraction layers</li>
        <li>Separation of concerns</li>
        <li>Fault tolerance</li>
        <li>Data integrity</li>
    </ul>
</div>
